package study;

public class ex01 {
		/*	JAVA 변수란?
			- 변수 (variable) : 값을 저장할 수 있는 메모리에 붙이는 이름
			- 상수 (constant) : 값을 한번 저장하면 변경할 수 없는 변수
		
			타입이란?
			- 자바는 변수에 다양한 타입의 값을 저장할 수 있다.
			- 하지만 타입을 맞춰줘야 함. (정수 타입 변수에는 정수값만, 실수 타입 변수에는 실수값만 가능)
			- 타입 (type) : 변수를 선언할 때 변수에 저장하는 데이터의 종류와 크기
		
			변수 선언
			타입 space 변수명;
			- int x;
			- double y;
			- char z;
		
			선언 후 저장
			변수명 = 값;
			x = 10;
			y = 10.1;
			z = 'A';
		
			선언 동시에 저장
			타입 space 변수명 = 값;
			- int x = 10;
			- double y = 5.5;
			- char z = '홍';
		
			그냥 int x; (정수형 x) 이렇게 단순하게 선언한 다음
			x = 10; (10을 x에 넣는다) 이렇게 10이라는 값을 x라는 변수에 저장해줘도 되고,
			int x = 10;	이렇게 바로 '10을 정수 x에 넣는다.'고 해줘도 된다.
		*/
		
		
		/*	아스키코드
		 	- 아스키코드란? 이진수의 전자신호를 사람이 인식할 수 있도록 저장해야 했기에 만드어진 코드
		 	
		 	- 확장 아스키 (ASCII) : 기존 아스키코드(7비트)에 1비트를 추가하여 256개의 문자를 표현.
		 							아스키코드는 1바이트로 1개의 문자를 표현함 (영어로 한정)
		 							예를들어 한글은 한 글자가 모음과 자음, 2개 문자의 합으로 만들어지는데,
		 							1바이트로 1개 문자를 표현하는 아스키코드로는 표현을 할 수 없다.
		 							확장 아스키코드의 한계. 그래서 유니코드가 탄생함.
		 	
		 	- 유니코드 (UniCode) :	2바이트로 전 세계 모든 문자를 표현할 수 있음.
		 */
		
		
		/*	오버플로우, 언더플로우
		 	- Overflow	:	데이터 타입이 저장할 수 있는 값의 범위를 초과한 경우,
		 	 				가장 작은 숫자로 돌아가서 다시 올라가게 됨.
		 	- Underflow :	데이터 타입이 저장할 수 있는 값의 범위보다 작은 값을 저장한 경우,
		 					가장 큰 숫자로 돌아가서 다시 올라가게 됨.
		 	
		 	ex) byte 타입은 -128 부터 127 까지를 담을 수 있는데, 만약 128을 담으려고 하면 -128 이 됨.
	 	*/
	public static void main(String[] args) {
		
		//	변수명을 알아보자
		int price1 = 100;
		int $price = 200;
		int _price = 300;
		
		//	int #price = 400;	//$나 _외에 다른 특수기호 사용 못함
		//	int 1price = 500;	숫자로 시작할 수 없음
		//	특수기호는 되도록 사용하지 않도록 한다.
		
		System.out.println(price1);
		System.out.println($price);
		System.out.println(_price);
		
		String firstname = "java";
		String firstName = "자바";
		
		//	String은 문자열을 젖아하는 타입이다.
		//	자바의 변수는 대소문자를 구별한다.
		
		
	/*	자바 타입, 형 변환 알아보기
	 	
	 	변수의 타입 (기본 자료형)
	 	실제 값을 저장하는 기본형 (Primitive type)은 총 8가지
	 	
	 	정수형 - byte, short, int, long
	 	문자형 - char (문자를 지정하지만, 실제 값으로는 정수가 저장됨)
	 	실수형 - float, double
	 	논리형 - boolean
	 	
	 	1. boolean
	 		- 논리 자료형
	 		- 1 byte
	 		- 입출력 범위 : true / false
	 		- 논리연산자를 사용
	 		
	 	2. 정수 (기본타입)
	 		- 모든 정수는 기본적으로 int형으로 나타냄.
	 		- long형을 표현할 때는 뒤에 접미사 소문자 'l' 혹은 대문자 'L'을 붙여준다.
	 		- byte형 정수나 short형 정수는 접미사가 없음.
	 		- int 끼리 연산속도가 가장 빠르기 때문에 정수를 굳이 byte나 short형으로 나타내지 않음.
	 		- char은 음수가 없는 특수타입임 !
	 		
	 		정수타입
	 		- byte	: 1byte, -2의 7승 ~ 2의 7승의 -1	-> 	-128 ~ 127
	 		- short : 2byte, -2의 15승 ~ 2의 15승의 -1	->	-32768 ~ 32767
	 		- int	: 4byte, -2의 31승 ~ 2의 31승의 -1	->	-2147483648 ~ 2147483647
	 		- long	: 8byte, -2의 63승 ~ 2의 63승의 -1	->	-9223372036854775808 ~ 92233720368545807
	 		
	 		문자타입
	 		- char	: 2byte, 0 ~ 2의 16승의 -1			->	0 ~ 65535 (유니코드)
	 		
	 	3. 실수
	 		- 메모리 사용은 각각 정수타입 int, long과 같지만, 사실 더 큰 범위의 값을 저장할 수 있다
	 		- 자바 실수타입의 기본 처리는 double !
	 		- float 타입에 값을 저장하려면, 실수 값 뒤에 'f' 또는 'F'를 붙여야 한다
	 		
	 		- float		: 4byte, 소수점 7자리
	 		- double	: 8byte, 소수점 15자리
	 */
	 		
/*	 		
	 	형 변환
	 		
	 		1. 자동 타입변환
	 			- 작은 크기의 데이터 타입을 큰 크기의 데이터 타입으로 변환하는 행위
	 			- 데이터 크기 : byte < short < int < long < float < double
	 						ex)	int c = 100;
	 							float d = c;
	 							d의 결과 : 100.0
	 							
	 							정수형 c에 100을 저장하고, 실수형 d에 c의 값인 100을 저장하려고 하면
	 							int와 float는 서로 다른 타입이기 때문에 형변환을 해줘야 한다.
	 							
	 							여기서 int차입이 float타입보다 작은 타입이기 때문에,
	 							큰 크기인 float으로는 무리없이 자동 변환되어 저장됨.
	 							
	 		2. 강제 타입변환 = 캐스팅
	 			- 큰 크기의 타입을 작은 타입으로 변환하려면 강제 타입변환을 해줘야 한다. 값 손실 발생.
	 			ex)	int는 4byte, byte는 1byte다. 때문에 int타입을 byte타입에 담을 수 없다.
*/
				int c = 128;
				byte d = (byte)c;	//	강제 타입변환
				//	지정된 타입보다 값이 더 클 경우 강제 타입변환을 하면
				//	(Overflow) : 가장 작은 값으로 돌아간다.
				System.out.println(d);

			// ex)
				double a = 3.14;
				int b = (int)a;
				//	double 타입이 int 타입보다 큰데, 이를 강제로 int 타입에 담아줬을 때,
				//	b의 값은 a의 정수부분인 3만 저장이 된다.
				System.out.println(b);
/*				
				음수가 없는 char 은 강제타입변환 해준다.
				
				
		String (문자열)
			- 작은 따옴표로 감싼 문자는 char타입 변수에 유니코드로 저장되지만,
			  큰 따옴표로 감싼 문자 또는 여러개의 문자는 유니코드로 변환되지 않는다.
			- 큰따옴표로 감싼 문자 = 문자열
			- 문자열은 string타입을 사용해줘야 함.
			ex)
			String st1 = "안녕"
 */
					
			byte e = 100;						//	1byte
			short f = 200;						//	2byte
			
			char g1 = 'A';						//	2byte
			//	문자는 작은따옴표를 쓴다
			char g2 = '\u0041';					//	유니코드 표현법
			char g3 = 65;						//	내부적으로 정수로 저장되기 때문에 오류 X
			
			int h = 1000;						//	4byte
			long i = 123456789L;				//	8byte
			
			float j = 3.14f;					//	4byte
			double k = 3.14192;					//	8byte
			
			boolean l = true;					//	1byte

/*			
		
		이스케이프 문자
			- 문자열 내부에 역슬래시(₩)를 사용해 문자열 내부에 특정 문자를 포함시킴.
			
			- ₩t : 탭만큼 띄움
			- ₩n : 줄 바꿈
			- ₩r : 캐리지리턴 (줄 바꿈)
			- ₩" : "출력
			- ₩' : '출력
			- ₩₩ : ₩출력
			- ₩u16진수 : 16진수 유니코드에 해당하는 문자 출력			
 */
					
	}

}
